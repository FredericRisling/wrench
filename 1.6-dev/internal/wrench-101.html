<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <title>WRENCH: WRENCH 101</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <script type="text/javascript" src="jquery.smartmenus.js"></script>
    <!-- SmartMenus jQuery Bootstrap Addon -->
    <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
    <!-- SmartMenus jQuery plugin -->
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a href="http://wrench-project.org" class="navbar-brand">
                <img alt="Logo" src="logo-horizontal.png" width="160" style="float: left"/>
                1.6-dev
            </a>
        </div>
        <div id="main-nav" class="nav navbar-nav navbar-right">
            <ul class="sm sm-dox nav navbar-nav navbar-right" id="main-menu">
                <li><a href="index.html">Overview</a></li>
                <li><a href="install.html">Installation</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="wrench-101.html">WRENCH 101</a></li>
                <li><a href="wrench-102.html">WRENCH 102</a></li>
                <li><a href="annotated.html">API Reference</a></li>
                <li style="float: right">
                    <input type="hidden" id="MSearchField">
                </li>
            </ul>
        </div>
    </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div class="content" id="content">
        <div class="container">
            <div class="row">
                <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                    <div style="margin-bottom: 15px;">
                        <!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">WRENCH 101 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#wrench-101-simulator-10000ft">10,000-ft view of a WRENCH simulator</a></li>
<li class="level1"><a href="#wrench-101-simulator-1000ft">1,000-ft view of a WRENCH simulator</a><ul><li class="level2"><a href="#wrench-101-simulator-1000ft-step-0">Step 0: Include wrench.h</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-1">Step 1: Create and initialize a simulation</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-2">Step 2: Instantiate a simulated platform</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-3">Step 3: Instantiate services on the platform</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-4">Step 4: Create at least one workflow</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-5">Step 5: Instantiate at least one WMS per workflow</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-6">Step 6: Launch the simulation</a></li>
<li class="level2"><a href="#wrench-101-simulator-1000ft-step-7">Step 7: Process simulation output</a></li>
</ul>
</li>
<li class="level1"><a href="#wrench-101-simulator-services">Available services</a></li>
<li class="level1"><a href="#wrench-101-customizing-services">Customizing Services</a></li>
<li class="level1"><a href="#wrench-101-logging">Customizing logging</a></li>
</ul>
</div>
<div class="textblock"><p>This page provides high-level and detailed information about what WRENCH simulators can simulate and how they do it. Full API details are provided in the <a href="../user/annotated.html">User API Reference</a>. See the relevant pages for instructions on how to <a class="el" href="install.html">install WRENCH</a> and how to <a class="el" href="getting-started.html">setup a simulator project</a>.</p>
<hr/>
<h1><a class="anchor" id="wrench-101-simulator-10000ft"></a>
10,000-ft view of a WRENCH simulator</h1>
<p>A WRENCH simulator can be as simple as a single <code>main()</code> function that creates a platform to be simulated (the hardware) and a set of services that run on the platform (the software). These services correspond to software that knows how to store data, perform computation, and many other useful things that real-world cyberinfrastructure services can do.</p>
<p>The simulator then creates a workflow to be executed, which consists of a set of compute tasks each with input and output files, with control- and data-dependencies between tasks.</p>
<p>A special service is then created, called a Workflow Management System (WMS), that will be in charge of executing the workflow on the platform using available hardware resources and software services. The WMS is implemented using the <a href="../developer/annotated.html">WRENCH Developer API</a>, as discussed in the <a class="el" href="wrench-102.html">WRENCH 102</a> page.</p>
<p>The simulation is then launched via a single call (<code><a class="el" href="classwrench_1_1_simulation.html#ae9589632de9a2311ed1d7f7747478985" title="Launch the simulation. ">wrench::Simulation::launch()</a></code>), and returns only once the WMS has terminated (after completing or failing to complete the execution of the workflow). Simulation output can be analyzed programmatically and/or dumped to a JSON file. This JSON file can be loaded into the <em>WRENCH dashboard</em> tool (just run the <code>wrench-dashboard</code> executable, which should have been installed on your system).</p>
<h1><a class="anchor" id="wrench-101-simulator-1000ft"></a>
1,000-ft view of a WRENCH simulator</h1>
<p>In this section, we dive deeper into what it takes to implement a WRENCH simulator. <em>To provide context, we refer to the example simulator in the</em> <code>examples/basic-examples/bare-metal-chain</code> <em>directory of the WRENCH distribution</em>. This simulator simulates the execution of a chain workflow on a two-host platform that runs one compute service and one storage service. Although other examples are available (see <code>examples/README.md</code>), this simple example is sufficient to showcase most of what a WRENCH simulator does, which consists in going through the steps below. Note that the simulator's code contains extensive comments as well.</p>
<h2><a class="anchor" id="wrench-101-simulator-1000ft-step-0"></a>
Step 0: Include wrench.h</h2>
<p>For ease of use, all WRENCH abstraction in the <a href="../user/annotated.html">WRENCH User API</a> are available through a single header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;wrench.h&gt;</span></div></div><!-- fragment --><h2><a class="anchor" id="wrench-101-simulator-1000ft-step-1"></a>
Step 1: Create and initialize a simulation</h2>
<p>The state of a WRENCH simulation is defined by the <code><a class="el" href="classwrench_1_1_simulation.html" title="A class that provides basic simulation methods. Once the simulation object has been explicitly or imp...">wrench::Simulation</a></code> class. A simulator must create an instance of this class and initialize it with the <code><a class="el" href="classwrench_1_1_simulation.html#a3c6d35f1f77f35cbc727ce31e5689992" title="Initialize the simulation, which parses out WRENCH-specific and SimGrid-specific command-line argumen...">wrench::Simulation::init()</a></code> member function. The bare-metal-chain simulator does this as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classwrench_1_1_simulation.html">wrench::Simulation</a> simulation;</div><div class="line">simulation.<a class="code" href="classwrench_1_1_simulation.html#a3c6d35f1f77f35cbc727ce31e5689992">init</a>(&amp;argc, argv);</div></div><!-- fragment --><p>Note that this member function takes in the command-line arguments passed to the main function of the simulator. This is so that it can parse WRENCH-specific and <a href="https://simgrid.org/doc/latest/Configuring_Simgrid.html">SimGrid-specific</a> command-line arguments. (Recall that WRENCH is based on <a href="htts://simgrid.org">SimGrid</a>.) Two useful such arguments are <code>--help-wrench</code>, which displays a WRENCH help message, and <code>--help-simgrid</code>, which displays an extensive SimGrid help message.</p>
<h2><a class="anchor" id="wrench-101-simulator-1000ft-step-2"></a>
Step 2: Instantiate a simulated platform</h2>
<p>This is done with the <code><a class="el" href="classwrench_1_1_simulation.html#ae22639abf6ede9f345b382f5ffe19b0e" title="Instantiate a simulated platform. ">wrench::Simulation::instantiatePlatform()</a></code> member function which takes as argument a <a href="https://simgrid.org/doc/latest/platform.html">SimGrid virtual platform description file</a>. Any SimGrid simulation, and thus any WRENCH simulation, must be provided with the description of the simulated hardware platform (compute hosts, clusters of hosts, storage resources, network links, routers, routes between hosts, etc.). The bare-metal-chain simulator comes with a platform description file, <code>examples/basic-examples/bare-metal-chain/two_hosts.xml</code>, which we include here:</p>
<div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&#39;1.0&#39;</span>?&gt;</div><div class="line">&lt;!<span class="keyword">DOCTYPE</span> <span class="keyword">platform</span> <span class="keyword">SYSTEM</span> <span class="stringliteral">&quot;http://simgrid.gforge.inria.fr/simgrid/simgrid.dtd&quot;</span>&gt;</div><div class="line">&lt;<span class="keywordtype">platform</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;4.1&quot;</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">zone</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;AS0&quot;</span> <span class="keyword">routing</span>=<span class="stringliteral">&quot;Full&quot;</span>&gt;</div><div class="line"></div><div class="line">        </div><div class="line">        &lt;<span class="keywordtype">host</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;WMSHost&quot;</span> <span class="keyword">speed</span>=<span class="stringliteral">&quot;10Gf&quot;</span> <span class="keyword">core</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div><div class="line">            &lt;<span class="keywordtype">disk</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;hard_drive&quot;</span> <span class="keyword">read_bw</span>=<span class="stringliteral">&quot;100MBps&quot;</span> <span class="keyword">write_bw</span>=<span class="stringliteral">&quot;100MBps&quot;</span>&gt;</div><div class="line">                &lt;<span class="keywordtype">prop</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;size&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;5000GiB&quot;</span>/&gt;</div><div class="line">                &lt;<span class="keywordtype">prop</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;mount&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;/&quot;</span>/&gt;</div><div class="line">            &lt;/<span class="keywordtype">disk</span>&gt;</div><div class="line">        &lt;/<span class="keywordtype">host</span>&gt;</div><div class="line"></div><div class="line">        </div><div class="line">        &lt;<span class="keywordtype">host</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;ComputeHost&quot;</span> <span class="keyword">speed</span>=<span class="stringliteral">&quot;1Gf&quot;</span> <span class="keyword">core</span>=<span class="stringliteral">&quot;10&quot;</span>&gt;</div><div class="line">            &lt;<span class="keywordtype">prop</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;ram&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;16GB&quot;</span> /&gt;</div><div class="line">       &lt;/<span class="keywordtype">host</span>&gt;</div><div class="line"></div><div class="line">        </div><div class="line">        &lt;<span class="keywordtype">link</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;network_link&quot;</span> <span class="keyword">bandwidth</span>=<span class="stringliteral">&quot;50MBps&quot;</span> <span class="keyword">latency</span>=<span class="stringliteral">&quot;20us&quot;</span>/&gt;</div><div class="line"></div><div class="line">        </div><div class="line">        &lt;<span class="keywordtype">route</span> <span class="keyword">src</span>=<span class="stringliteral">&quot;WMSHost&quot;</span> <span class="keyword">dst</span>=<span class="stringliteral">&quot;ComputeHost&quot;</span>&gt;</div><div class="line">            &lt;<span class="keywordtype">link_ctn</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;network_link&quot;</span>/&gt;</div><div class="line">        &lt;/<span class="keywordtype">route</span>&gt;</div><div class="line">    &lt;/<span class="keywordtype">zone</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">platform</span>&gt;</div></div><!-- fragment --><p>This file defines a platform with two hosts, <code>WMSHost</code> and <code>ComputeHost</code>. The former is a 1-core host with compute speed 10 Gflop/sec, with a 5000-GiB disk with 100 MB/sec read and write bandwidth, which is mounted at <code>/</code>. The latter is a 10-core host where each core computes at speed 1Gflop/sec and with a total RAM capacity of 16 GB. Both hosts are interconnected by a network link with 50 MB/sec bandwidth and 20 us latency. We refer the reader to platform description files in other examples in the <code>examples</code> directory and to the <a href="https://simgrid.org/doc/latest/platform.html">SimGrid documentation</a> for more information on how to create platform description files.</p>
<p>The bare-metal-chain simulator takes the path to the platform description as its 2nd command-line argument and thus instantiates the simulated platform as:</p>
<div class="fragment"><div class="line">simulation.<a class="code" href="classwrench_1_1_simulation.html#ae22639abf6ede9f345b382f5ffe19b0e">instantiatePlatform</a>(argv[2]);</div></div><!-- fragment --><h2><a class="anchor" id="wrench-101-simulator-1000ft-step-3"></a>
Step 3: Instantiate services on the platform</h2>
<p>While the previous step defines the hardware platform, this step defines what software services run on that hardware. The <code><a class="el" href="classwrench_1_1_simulation.html#a7cf70e5793758149a8bf29992d870c91" title="Method to add a service to the simulation. ">wrench::Simulation::add()</a></code> member function is used to add services to the simulation. Each class of service is created with a particular constructor, which also specifies host(s) on which the service is to be started. Typical kinds of services include compute services, storage services, and file registry services (see <a class="el" href="wrench-101.html#wrench-101-simulator-services">below</a> for more details).</p>
<p>The bare-metal-chain simulator instantiates three services. The first one is a compute service:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bare_metal_service = simulation.<a class="code" href="classwrench_1_1_simulation.html#a7cf70e5793758149a8bf29992d870c91">add</a>(<span class="keyword">new</span> <a class="code" href="classwrench_1_1_bare_metal_compute_service.html">wrench::BareMetalComputeService</a>(<span class="stringliteral">&quot;ComputeHost&quot;</span>, {<span class="stringliteral">&quot;ComputeHost&quot;</span>}, <span class="stringliteral">&quot;&quot;</span>, {}, {}));</div></div><!-- fragment --><p>The <code><a class="el" href="classwrench_1_1_bare_metal_compute_service.html" title="A compute service that manages a set of multi-core compute hosts and provides access to their resourc...">wrench::BareMetalComputeService</a></code> class implements a simulation of a compute service that greedily runs jobs submitted to it. You can think of it as a compute server that simply fork-execs (possibly multi-threaded) processes upon request, only ensuring that physical RAM capacity is not exceeded. In this particular case, the compute service is started on host <code>ComputeHost</code>. It has access to the compute resources of that same host (2nd argument). The third argument corresponds to the path of some scratch storage, i.e., storage in which data can be stored temporarily while a job runs. In this case, the scratch storage specification is empty as host <code>ComputeHost</code> has no disk attached to it. (See the <code>examples/basic-examples/bare-metal-chain-scratch</code> example simulator, in which scratch storage is used). The last two arguments are <code>std::map</code> objects (in this case both empty), that are used to configure properties of the compute service (see details in [this section below](-101-customizing-services)).</p>
<p>The second service is a storage service:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> storage_service = simulation.<a class="code" href="classwrench_1_1_simulation.html#a7cf70e5793758149a8bf29992d870c91">add</a>(<span class="keyword">new</span> <a class="code" href="classwrench_1_1_simple_storage_service.html">wrench::SimpleStorageService</a>( <span class="stringliteral">&quot;WMSHost&quot;</span>, {<span class="stringliteral">&quot;/&quot;</span>}, {{<a class="code" href="classwrench_1_1_storage_service_property.html#a4a15fb8290bd904973c923a6e7d7ca39">wrench::SimpleStorageServiceProperty::BUFFER_SIZE</a>, <span class="stringliteral">&quot;50000000&quot;</span>}}, {}));</div></div><!-- fragment --><p>The <code><a class="el" href="classwrench_1_1_simple_storage_service.html" title="A storage service that provides direct access to some storage resources (e.g., one or more disks)...">wrench::SimpleStorageService</a></code> class implements a simulation of a remotely-accessible storage service on which files can be stored, copied, deleted, read, and written. In this particular case, the storage service is started on host <code>WMSHost</code>. It uses storage mounted as <code>/</code>. The last two arguments, as for the compute service, are used to configure particular properties of the service. In this case, the service is configured to use a 50-MB buffer size to pipeline network and disk accesses (see details in <a class="el" href="wrench-101.html#wrench-101-customizing-services">this section below</a>).</p>
<p>The third service is a file registry service:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> file_registry_service = <span class="keyword">new</span> <a class="code" href="classwrench_1_1_file_registry_service.html">wrench::FileRegistryService</a>(<span class="stringliteral">&quot;WMSHost&quot;</span>); </div><div class="line">simulation.<a class="code" href="classwrench_1_1_simulation.html#a7cf70e5793758149a8bf29992d870c91">add</a>(file_registry_service); </div></div><!-- fragment --><p>The <code><a class="el" href="classwrench_1_1_file_registry_service.html" title="A file registry service (a.k.a. replica catalog) that holds a database of which files are available a...">wrench::FileRegistryService</a></code> class implements a simulation of a key-values pair service that stores for each file (the key) the locations where the file is available for read/write access (the values). This service can be used by a WMS to find out where workflow files are located (and is often required - see Step #4 hereafter).</p>
<h2><a class="anchor" id="wrench-101-simulator-1000ft-step-4"></a>
Step 4: Create at least one workflow</h2>
<p>Every WRENCH simulator simulates the execution of a workflow, and thus must create an instance of the <code><a class="el" href="classwrench_1_1_workflow.html" title="A workflow (to be executed by a WMS) ">wrench::Workflow</a></code> class. This class has member functions to manually create tasks and files and add them to the workflow. For instance, the bare-metal-chain simulator does this as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classwrench_1_1_workflow.html">wrench::Workflow</a> workflow;</div><div class="line"></div><div class="line"><span class="comment">/* Add workflow tasks */</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; num_tasks; i++) {</div><div class="line">  <span class="comment">/* Create a task: 10GFlop, 1 to 10 cores, 0.90 parallel efficiency, 10MB memory footprint */</span></div><div class="line">  <span class="keyword">auto</span> task = workflow.<a class="code" href="classwrench_1_1_workflow.html#a1c55d600aa8cc00d245d2ca6f01cd799">addTask</a>(<span class="stringliteral">&quot;task_&quot;</span> + std::to_string(i), 10000000000.0, 1, 10, 0.90, 10000000);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Add workflow files */</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; num_tasks+1; i++) {</div><div class="line">  <span class="comment">/* Create a 100MB file */</span></div><div class="line">  workflow.<a class="code" href="classwrench_1_1_workflow.html#a0e1f7dc16f875f18c0990e6bd1843932">addFile</a>(<span class="stringliteral">&quot;file_&quot;</span> + std::to_string(i), 100000000);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Set input/output files for each task */</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; num_tasks; i++) {</div><div class="line">  <span class="keyword">auto</span> task = workflow.<a class="code" href="classwrench_1_1_workflow.html#a43d89af79196164d060115ee25200306">getTaskByID</a>(<span class="stringliteral">&quot;task_&quot;</span> + std::to_string(i));</div><div class="line">  task-&gt;<a class="code" href="classwrench_1_1_workflow_task.html#a3498047afb74ea6ce2132d44f8c678e8">addInputFile</a>(workflow.<a class="code" href="classwrench_1_1_workflow.html#a19b3b6f36f684f8c367f42a818b0a0c2">getFileByID</a>(<span class="stringliteral">&quot;file_&quot;</span> + std::to_string(i)));</div><div class="line">  task-&gt;addOutputFile(workflow.<a class="code" href="classwrench_1_1_workflow.html#a19b3b6f36f684f8c367f42a818b0a0c2">getFileByID</a>(<span class="stringliteral">&quot;file_&quot;</span> + std::to_string(i + 1)));</div><div class="line">}</div></div><!-- fragment --><p>The above creates a "chain" workflow (hence the name of the simulator), in which the output from one task is input to the next task. The number of tasks is obtained from a command-line argument.</p>
<p>The <code><a class="el" href="classwrench_1_1_workflow.html" title="A workflow (to be executed by a WMS) ">wrench::Workflow</a></code> class also provides member functions to import workflows from workflow description files in standard <a href="https://github.com/workflowhub/workflow-schema">JSON format</a> and <a href="http://workflowarchive.org">DAX format</a>.</p>
<p>The input files to the workflow must be available (at some storage service) before the simulated workflow execution begins. These are the files that are input to some tasks, but not output from any task. They must be "staged" on some storage service, and the bare-metal-chain simulator does it as:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;f : workflow.<a class="code" href="classwrench_1_1_workflow.html#ad9af24c910d8148353d3b5296d5afb99">getInputFiles</a>()) {</div><div class="line">  simulation.<a class="code" href="classwrench_1_1_simulation.html#a2b3017119ebe22dfea36423138bb6fa8">stageFile</a>(f, storage_service);</div><div class="line">}</div></div><!-- fragment --><p>Note that in this particular case there is a single input file. But the code above is more general, as it iterates over all workflow input files. The above code will throw an exception if no <code><a class="el" href="classwrench_1_1_file_registry_service.html" title="A file registry service (a.k.a. replica catalog) that holds a database of which files are available a...">wrench::FileRegistryService</a></code> instance has been added to the simulation.</p>
<h2><a class="anchor" id="wrench-101-simulator-1000ft-step-5"></a>
Step 5: Instantiate at least one WMS per workflow</h2>
<p>One special service that must be started is a Workflow Management System (WMS) service, i.e., software that is in charge of executing the workflow given available software and hardware resources. The bare-metal-chain simulator does this as:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> wms = simulation.<a class="code" href="classwrench_1_1_simulation.html#a7cf70e5793758149a8bf29992d870c91">add</a>(<span class="keyword">new</span> wrench::OneTaskAtATimeWMS({baremetal_service}, {storage_service}, <span class="stringliteral">&quot;WMSHost&quot;</span>));</div></div><!-- fragment --><p>Class <code>wrench::OneTaskAtATimeWMS</code>, which is part of this example simulator, is implemented using the <a href="../developer/annotated.html">WRENCH Developer API</a>. See the <a class="el" href="wrench-102.html">WRENCH 102</a> page for information on how to implement a WMS with WRENCH. The code above passes the list of compute services (1st argument) and the list of storage services (2nd argument) to the WMS constructor. The 3rd argument specifies that the WMS should run on host <code>WMSHost</code>.</p>
<p>The previously created workflow is then associated to the WMS:</p>
<div class="fragment"><div class="line">wms-&gt;addWorkflow(&amp;workflow);</div></div><!-- fragment --><h2><a class="anchor" id="wrench-101-simulator-1000ft-step-6"></a>
Step 6: Launch the simulation</h2>
<p>This is the easiest step, and is done by simply calling <code><a class="el" href="classwrench_1_1_simulation.html#ae9589632de9a2311ed1d7f7747478985" title="Launch the simulation. ">wrench::Simulation::launch()</a></code>:</p>
<div class="fragment"><div class="line">simulation.<a class="code" href="classwrench_1_1_simulation.html#ae9589632de9a2311ed1d7f7747478985">launch</a>();</div></div><!-- fragment --><p>This call checks the simulation setup, and blocks until the WMS terminates.</p>
<h2><a class="anchor" id="wrench-101-simulator-1000ft-step-7"></a>
Step 7: Process simulation output</h2>
<p>Once <code><a class="el" href="classwrench_1_1_simulation.html#ae9589632de9a2311ed1d7f7747478985" title="Launch the simulation. ">wrench::Simulation::launch()</a></code> has returned, simulation output can be processed programmatically. The <code><a class="el" href="classwrench_1_1_simulation.html#aff0338aa6831c6ac252cf0673fe68f44" title="Get the simulation output object. ">wrench::Simulation::getOutput()</a></code> member function returns an instance of class <code><a class="el" href="classwrench_1_1_simulation_output.html" title="A class that contains post-mortem simulation-generated data. ">wrench::SimulationOutput</a></code>. Note that there are member functions to configure the type and amount of output generated (see the <code>wrench::SimulationOutput::enable*Timestamps()</code> member functions). The bare-metal-chain simulator does minimal output processing as:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> trace = simulation.<a class="code" href="classwrench_1_1_simulation.html#aff0338aa6831c6ac252cf0673fe68f44">getOutput</a>().<a class="code" href="classwrench_1_1_simulation_output.html#a1d03324f34db985d0e181e42cf30cd9d">getTrace</a>&lt;<a class="code" href="classwrench_1_1_simulation_timestamp_task_completion.html">wrench::SimulationTimestampTaskCompletion</a>&gt;();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;item : trace) {</div><div class="line">   std::cerr &lt;&lt; <span class="stringliteral">&quot;Task &quot;</span>  &lt;&lt; item-&gt;getContent()-&gt;<a class="code" href="classwrench_1_1_simulation_timestamp_task.html#a9a9440d71940fccf0fb33383ce056a37">getTask</a>()-&gt;<a class="code" href="classwrench_1_1_workflow_task.html#a18ce8967b4b59d2d231a1218a8d3b813">getID</a>() &lt;&lt; <span class="stringliteral">&quot; completed at time &quot;</span> &lt;&lt; item-&gt;getDate()  &lt;&lt; std::endl;</div></div><!-- fragment --><p>Specifically, class <code><a class="el" href="classwrench_1_1_simulation_output.html" title="A class that contains post-mortem simulation-generated data. ">wrench::SimulationOutput</a></code> has a templated <code><a class="el" href="classwrench_1_1_simulation_output.html#a1d03324f34db985d0e181e42cf30cd9d" title="Retrieve a copy of a simulation output trace once the simulation has completed. ">wrench::SimulationOutput::getTrace()</a></code> member function to retrieve traces for various information types. The first line of code above returns a <code>std::vector</code> of time-stamped task completion events. The second line of code iterates through this vector and prints task names and task completion dates (in seconds). The classes that implement time-stamped events are all classes named <code>wrench::SimulationTimestampSomething</code>, where "_Something_" is self-explanatory (e.g., TaskCompletion, TaskFailure).</p>
<p>Another kind of output is (simulated) energy consumption. WRENCH leverages <a href="https://simgrid.org/doc/latest/Plugins.html#existing-plugins">SimGrid's energy plugin</a>, which provides accounting for computing time and dissipated energy in the simulated platform. SimGrid's energy plugin requires host <code>pstate</code> definitions (levels of performance, CPU frequency) in the <a href="https://simgrid.org/doc/latest/platform.html">XML platform description file</a>. The <code>wrench::Simulation::getEnergyConsumed()</code> member function returns energy consumed by all hosts in the platform. <b>Important:</b> The energy plugin is NOT enabled by default in WRENCH simulations. To enable it, pass the <code>--activate-energy</code> command line option to the simulator. See <code>examples/basic-examples/cloud-bag-of-tasks-energy</code> for an example simulator that makes use of this plugin (and example platform description file that defines host power consumption profiles).</p>
<p>Another option altogether is to dump all simulation output to a JSON file. This is done with the <code>wrench::SimulationOutput::dump*JSON()</code> member functions. See the documentation of each member function to see the structure of the JSON output, in case you want to parse/process the JSON yourself. Alternately, you can run the installed <code>wrench-dashboard</code> tool, which provides interactive visualization/inspection of simulation output.</p>
<h1><a class="anchor" id="wrench-101-simulator-services"></a>
Available services</h1>
<p>Below is the list of services available to-date in WRENCH. Click on the corresponding links for more information on what these services are and on how to create them.</p>
<ul>
<li><b>Compute Services</b>: These are services that know how to compute workflow tasks:<ul>
<li><a class="el" href="guide-101-baremetal.html">Bare-metal Servers</a></li>
<li><a class="el" href="guide-101-cloud.html">Cloud Platforms</a></li>
<li><a class="el" href="guide-101-virtualizedcluster.html">Virtualized Cluster Platforms</a></li>
<li><a class="el" href="guide-101-batch.html">Batch-scheduled Clusters</a></li>
<li><a class="el" href="guide-101-htcondor.html">HTCondor</a></li>
</ul>
</li>
<li><b>Storage Services</b>: These are services that know how to store and give access to workflow files:<ul>
<li><a class="el" href="guide-101-simplestorage.html">Simple Storage Service</a></li>
</ul>
</li>
<li><b>File Registry Services</b>: These services, also known as <em>replica catalogs</em>, are simply databases of <code>&lt;filename, list of locations&gt;</code> key-values pairs of the storage services on which a copies of files are available.<ul>
<li><a class="el" href="guide-101-fileregistry.html">File Registry Service</a></li>
</ul>
</li>
<li><b>Network Proximity Services</b>: These are services that monitor the network and maintain a database of host-to-host network distances:<ul>
<li><a class="el" href="guide-101-networkproximity.html">Network Proximity Service</a></li>
</ul>
</li>
<li><b>EnergyMeter Services</b>: These services are used to periodically measure host energy consumption and include these measurements in the simulation output (see <a class="el" href="wrench-101.html#wrench-101-simulator-1000ft-step-7">this section</a>).<ul>
<li>Energy Meter Service</li>
</ul>
</li>
<li><b>Workflow Management Systems (WMSs)</b> (derives <code><a class="el" href="classwrench_1_1_w_m_s.html" title="A workflow management system (WMS) ">wrench::WMS</a></code>): A WMS provides the mechanisms for executing workflow applications, include decision-making for optimizing various objectives (often attempting to minimize workflow execution time). At least <b>one</b> WMS should be provided for running a simulation. By default, WRENCH does <b>not</b> provide a WMS implementation as part of its core components. Each example simulator in the <code>examples/</code> directory implements its own WMS. Additional WMSs implementations may also be found on the <a href="https://wrench-project.org/usages.html">WRENCH project website</a>. See <a class="el" href="wrench-102.html">WRENCH 102</a> for information on how to implement a WMS.</li>
</ul>
<h1><a class="anchor" id="wrench-101-customizing-services"></a>
Customizing Services</h1>
<p>Each service is customizable by passing to its constructor a <em>property list</em>, i.e., a key-value map where each key is a property and each value is a string. Each service defines a property class. For instance, the <code><a class="el" href="classwrench_1_1_service.html" title="A service that can be added to the simulation and that can be used by a WMS when executing a workflow...">wrench::Service</a></code> class has an associated <code><a class="el" href="classwrench_1_1_service_property.html" title="Configurable properties for a Service. ">wrench::ServiceProperty</a></code> class, the <code><a class="el" href="classwrench_1_1_compute_service.html" title="The compute service base class. ">wrench::ComputeService</a></code> class has an associated <code><a class="el" href="classwrench_1_1_compute_service_property.html" title="Configurable properties for a ComputeService. ">wrench::ComputeServiceProperty</a></code> class, and so on at all levels of the service class hierarchy.</p>
<p><b>The API documentation for these property classes explains what each property means, what possible values are, and what default values are.</b> Other properties have more to do with what the service can or should do when in operation. For instance, the <code><a class="el" href="classwrench_1_1_batch_compute_service_property.html" title="Configurable properties for a BatchComputeService. ">wrench::BatchComputeServiceProperty</a></code> class defines a <code><a class="el" href="classwrench_1_1_batch_compute_service_property.html#a4e88135150aea2df7f815f7d751f03c7" title="The batch scheduling algorithm. Can be: ">wrench::BatchComputeServiceProperty::BATCH_SCHEDULING_ALGORITHM</a></code> which specifies what scheduling algorithm a batch service should use for prioritizing jobs. All property classes inherit from the <code><a class="el" href="classwrench_1_1_service_property.html" title="Configurable properties for a Service. ">wrench::ServiceProperty</a></code> class, and one can explore that hierarchy to discover all possible (and there are many) service customization opportunities.</p>
<p>Finally, each service exchanges messages on the network with other services (e.g., a WMS service sends a "do some work" message to a compute service). The size in bytes, or payload, of all messages can be customized similarly to the properties, i.e., by passing a key-value map to the service's constructor. For instance, the <code><a class="el" href="classwrench_1_1_service_message_payload.html" title="Configurable message payloads for a Service. ">wrench::ServiceMessagePayload</a></code> class defines a <code><a class="el" href="classwrench_1_1_service_message_payload.html#a9efb4a6b2c8876e17a3f636ba5ac17f6" title="The number of bytes in the control message sent to the daemon to terminate it. ">wrench::ServiceMessagePayload::STOP_DAEMON_MESSAGE_PAYLOAD</a></code> property which can be used to customize the size, in bytes, of the control message sent to the service daemon (that is the entry point to the service) to tell it to terminate. Each service class has a corresponding message payload class, and the API documentation for these message payload classes details all messages whose payload can be customized.</p>
<h1><a class="anchor" id="wrench-101-logging"></a>
Customizing logging</h1>
<p>When running a WRENCH simulator you may notice that there is quite a bit of logging output. While logging output can be useful to inspect visually the way in which the simulation proceeds, it is also convenient to disable it (and it slows down the simulation!). WRENCH's logging system is a thin layer on top of SimGrid's logging system, and as such is controlled via command-line arguments.</p>
<p>The <code>bare-metal-chain</code> example simulator can be executed as follows in the <code>examples/basic-examples/bare-metal-chain</code> directory:</p>
<div class="fragment"><div class="line">./wrench-example-bare-metal-chain 10 ./two_hosts.xml</div></div><!-- fragment --><p>You will note that quite a bit of (multi-colored) output is produced.</p>
<p>A first way in which to modify logging is to disable colors, which can be useful to redirect output to a file. This is done with the <code>--wrench-no-color</code> command-line option, anywhere in the argument list, for instance:</p>
<div class="fragment"><div class="line">./<a class="code" href="namespacewrench.html">wrench</a>-example-bare-metal-chain 10 ./two_hosts.xml --<a class="code" href="namespacewrench.html">wrench</a>-no-color</div></div><!-- fragment --><p>Disabling all logging is done with the option <code>--wrench-no-log</code>:</p>
<div class="fragment"><div class="line">./<a class="code" href="namespacewrench.html">wrench</a>-example-bare-metal-chain 10 ./two_hosts.xml --<a class="code" href="namespacewrench.html">wrench</a>-no-log</div></div><!-- fragment --><p>The above <code>--wrench-no-log</code> option is a simple wrapper around the sophisticated SimGrid logging capabilities (it is equivalent to the SimGrid argument <code>--log=root.threshold:critical</code>). Details on these capabilities are displayed when passing the <code>--help-logs</code> command-line argument to your simulator. In a nutshell, particular "log categories" can be toggled on and off. Log category names are attached to <code>*.cpp</code> files in the simulator code, the WRENCH code, and the SimGrid code. Using the <code>--help-log-categories</code> command-line argument shows the entire log category hierarchy.</p>
<p>In the <code>bare-metal-chain</code> example simulator, there is a log category called <code>custom_wms</code> for the WMS (see one of the first lines of <code>examples/basic-examples/bare-metal-chain/OneTaskAtATimeWMS.cpp</code>). This category corresponds to the logging messages printed out by the WMS. It is typical to want to see these messages as the WMS is the brain of the workflow execution. They can be enabled while other messages are disabled as follows:</p>
<div class="fragment"><div class="line">./<a class="code" href="namespacewrench.html">wrench</a>-example-bare-metal-chain 10 ./two_hosts.xml --<a class="code" href="namespacewrench.html">wrench</a>-no-log --log=custom_wms.threshold=info</div></div><!-- fragment --><p>When running the simulator in this way, you should only see green output, which only includes messages printed by the WMS.</p>
<p>See the <a href="https://simgrid.org/doc/latest/outcomes.html">Simgrid logging documentation</a> for all details. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
<address class="footer">
    <small>
        Generated by &#160;<a href="http://www.doxygen.org/index.html">
        <img class="footer" src="doxygen.png" alt="doxygen"/>
    </a> 1.8.13
    </small>
</address>
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-18066333-6', 'auto');
    ga('send', 'pageview');
</script>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
